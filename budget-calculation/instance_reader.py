# ---------------------------------------------------------------------------------------------------------------------
# Helper methods to read from the .cor instance file for Wildlife corridor design as generated by the instance
# generator available at: http://computational-sustainability.cis.cornell.edu/Datasets/corGenerator.zip
#
# This file is part of the wildlife_corridor_design_instances repository which is released under the MIT license.
# See file at https://github.com/angee/wildlife_corridor_design_instances/blob/master/LICENSE for full license details.
#
# Author: Andrea Rendl-Pitrey, Satalia, October 2020
# ---------------------------------------------------------------------------------------------------------------------

import networkx as nx


def extract_info_from_cor_file(file_name: str) -> (int, int, list, list, list, list):
    """
    Extracts all relevant information from the given .cor instance file
    :param file_name: the name (and path to) the .cor file
    :return: the instance information stated in the file
    """
    with open(file_name) as f:
        lines = f.readlines()
        nb_nodes = 0
        nb_reserves = 0
        is_reserve = []
        profit = []
        cost = []
        adjacency_matrix = []

        for line in lines:
            if line.startswith("c"):
                continue  # ignore comments
            if line.startswith("p"):
                vals = line.split()
                nb_nodes = int(vals[1])
                nb_reserves = int(vals[2])
                is_reserve = [-1] * nb_nodes
                profit = [-1] * nb_nodes
                cost = [-1] * nb_nodes
                adjacency_matrix = [[]] * nb_nodes
            # parse node information
            if line.startswith("n"):
                adjacency = [0] * nb_nodes
                # the line consists of the following entries:
                # n id reserve? utility cost #neighbouring-nodes i1 i2 ...  ie
                vals = line.split()
                id = int(vals[1])
                is_reserve[id] = int(vals[2])
                profit[id] = int(vals[3])
                cost[id] = int(vals[4])
                nb_neighbours = int(vals[5])
                for i in range(6, 6 + nb_neighbours):
                    neighbour = int(vals[i])
                    adjacency[neighbour] = 1
                adjacency_matrix[id] = adjacency

    return nb_nodes, nb_reserves, is_reserve, profit, cost, adjacency_matrix


def create_graph_from_adjacency_matrix(nb_nodes: int, adjacency_matrix: list, cost: list) -> nx.Graph:
    """
    Creates the undirected graph represented by the adjacency matrix and the costs on the nodes.

    :param nb_nodes: number of nodes in the graph
    :param adjacency_matrix: two-dimensional matrix (nb_nodes x nb_nodes) with 0-1 entries
    :param cost: list of length nb_nodes that contains the cost of each node
    :return:
    """
    graph = nx.Graph()
    for source in range(1, nb_nodes - 1):
        for target in range(source + 1, nb_nodes):
            if adjacency_matrix[source][target] == 1:
                if not graph.has_node(source):
                    graph.add_node(source, cost=cost[source])
                if not graph.has_node(target):
                    graph.add_node(target, cost=cost[target])
                graph.add_edge(source, target)
    return graph